# DataSonnet Libraries
:toc:
:toclevels: 1

## core

### `groupBy(array|object items, function discriminator)`
Groups the provided items into an object based on the function discriminator.

*Example*

.Payload
----------
{
  "languages": [
    {
      "name": "Foo",
      "language": {
          "name": "Java",
          "version": "1.8"
      }
    },
    {
      "name": "Bar",
      "language": {
          "name": "Scala",
          "version": "1.0"
      }
    },
    {
      "name": "FooBar",
      "language": {
          "name": "Java",
          "version": "1.7"
      }
    }
  ]
}
----------
.DataSonnet map:
------------------------
{
  languageGroups: ds.groupBy(payload.languages, function(item,index) item.language.name)
}
------------------------
.Result
------------------------
{
    "languageGroups": {
       "Java": [
          {
             "language": {
                "name": "Java",
                "version": "1.8"
             },
             "name": "Foo"
          },
          {
             "language": {
                "name": "Java",
                "version": "1.7"
             },
             "name": "FooBar"
          }
       ],
       "Scala": [
          {
             "language": {
                "name": "Scala",
                "version": "1.0"
             },
             "name": "Bar"
          }
       ]
    }
}
------------------------

### `remove(object obj, string keyName)`
Removes a property with given name from the object and returns the remaining object

*Example*

.Payload
----------
{
   "availableSeats": 45,
   "airlineName": "Delta",
   "aircraftBrand": "Boeing",
   "aircraftType": "717",
   "departureDate": "01/20/2019",
   "origin": "PHX",
   "destination": "SEA"
 }
----------
.DataSonnet map:
------------------------
ds.remove(payload, 'availableSeats')
------------------------
.Result
------------------------
{
   "airlineName": "Delta",
   "aircraftBrand": "Boeing",
   "aircraftType": "717",
   "departureDate": "01/20/2019",
   "origin": "PHX",
   "destination": "SEA"
 }
------------------------

### `reverse(array arr)`
Returns an array with elements in reverse order.

*Example*

.Payload
----------
[
    "a",
    "b",
    "c",
    "d"
]
----------
.DataSonnet map:
------------------------
ds.reverse(payload)
------------------------
.Result
------------------------
[
    "d",
    "c",
    "b",
    "a",
]
------------------------

### `parseDouble(string str)`

Parses a string which contains a double number and returns its numeric representation

*Example*

.Payload
----------
{
    "numberAsString": "123.45679"
}

----------
.DataSonnet map:
------------------------
{
    num: ds.parseDouble(payload.numberAsString)
}
------------------------
.Result
------------------------
{
    "num": 123.45679
}
------------------------

## crypto

### `hash(string value, string algorithm)`
Calculates hash of a String value using one of the supported algorithms. The `algorithm` must be one of `MD2`, `MD5`, `SHA-1`, `SHA-256`, `SHA-384`, `SHA-512`
The response is a string containing the hash bytes.

*Example:*

------------------------
{
    hashValue: ds.crypto.hash("HelloWorld", "MD5")
}
------------------------
.Result
------------------------
{
    "hashValue": "68e109f0f40ca72a15e05cc22786f8e6"
}
------------------------
### `hmac(string value, string secret, string algorithm)`
Generates hash-based message autentication code using provided secret and a hash function algorithm. The `algoritm` must be one of `HmacSHA1`, `HmacSHA256` or `HmacSHA512`.

*Example:*

------------------------
{
    hmacValue: ds.crypto.hmac("HelloWorld", "DataSonnet rules!", "HmacSHA256")
}
------------------------
.Result
------------------------
{
    "hmacValue": "7854220ef827b07529509f68f391a80bf87fff328dbda140ed582520a1372dc1"
}
------------------------

## datetime

### `now()`
Returns the current date/time from the system UTC clock in ISO-8601 format.

*Example*

------------------------
{
    currentZuluTime: ds.datetime.now()
}
------------------------

.Result:
------------------------
{
    "currentZuluTime": "2019-08-19T18:58:38.313Z"
}
------------------------

### `format(string datetime, string inputFormat, string outputFormat)`
Reformats a zoned date-time string.

*Example*

------------------------
ds.datetime.format("2019-07-04T21:00:00Z", "yyyy-MM-dd'T'HH:mm:ssVV", "d MMM uuuu")
------------------------
.Result:
------------------------
4 Jul 2019
------------------------

### `compare(string datetime1, string format1, string datetime2, string format2)`
Returns 1 if datetime1 > datetime2, -1 if datetime1 < datetime2, 0 if datetime1 == datetime2.

### `changeTimeZone(string datetime, string format, string timezone)`
Changes the date timezone, retaining the instant. This normally results in a change to the local date-time.
The response is formatted using the same format as an input.

*Example*

------------------------
ds.datetime.changeTimeZone("2019-07-04T21:00:00-0500", "yyyy-MM-dd'T'HH:mm:ssZ", "America/Los_Angeles")
------------------------
.Result:
------------------------
2019-07-04T19:00:00-0700
------------------------

### `toLocalDate(string datetime, string format)`
Returns only local date part of the `datetime` parameter in the ISO-8601 format without the offset.

*Example*

------------------------
ds.datetime.toLocalDate("2019-07-04T21:00:00-0500", "yyyy-MM-dd'T'HH:mm:ssZ")
------------------------
.Result:
------------------------
2019-07-04
------------------------

### `toLocalTime(string datetime, string format)`
Returns only local time part of the `datetime` parameter in the ISO-8601 format without the offset.

*Example*

------------------------
ds.datetime.toLocalTime("2019-07-04T21:00:00-0500", "yyyy-MM-dd'T'HH:mm:ssZ")
------------------------
.Result:
------------------------
21:00:00
------------------------

### `toLocalDateTime(string datetime, string format)`
Returns local datetime part of the `datetime` parameter in the ISO-8601 format without the offset.

*Example*

------------------------
ds.datetime.toLocalDateTime("2019-07-04T21:00:00-0500", "yyyy-MM-dd'T'HH:mm:ssZ")
------------------------
.Result:
------------------------
2019-07-04T21:00:00
------------------------

## localdatetime

### `now()`
Returns the current date/time from the system UTC clock in ISO-8601 format without a time zone.

*Example*

------------------------
{
    currentLocalTime: ds.localdatetime.now()
}
------------------------

.Result:
------------------------
{
    "currentLocalTime": "2019-08-19T18:58:38.313"
}
------------------------

### `offset(string datetime, string period)`
Returns a copy of this datetime with the specified amount added. The `datetime` parameter is in the ISO-8601 format without an offset.
The `period` is a string in the ISO-8601 period format.

*Example*

------------------------
ds.localdatetime.offset("2019-07-22T21:00:00", "P1Y1D")
------------------------
.Result:
------------------------
2020-07-23T21:00:00
------------------------

### `format(string datetime, string inputFormat, string outputFormat)`
Reformats a local date-time string.

*Example*

------------------------
ds.localdatetime.format("2019-07-04T21:00:00", "yyyy-MM-dd'T'HH:mm:ss", "d MMM uuuu")
------------------------
.Result:
------------------------
4 Jul 2019
------------------------

### `compare(string datetime1, string format1, string datetime2, string format2)`
Returns `1` if `datetime1 > datetime2`, `-1` if `datetime1 < datetime2`, and `0` if `datetime1 == datetime2`.
The `format1` and `format2` parameters must not have an offset or time zone.

*Example*

------------------------
ds.localdatetime.compare("2019-07-04T21:00:00", "yyyy-MM-dd'T'HH:mm:ss", "2019-07-04T21:00:00", "yyyy-MM-dd'T'HH:mm:ss")
------------------------
.Result:
------------------------
0
------------------------

## jsonpath

### `select(object json, string path)`

Evaluates JsonPath expression and returns the resulting JSON object.
It uses the https://github.com/json-path/JsonPath[Jayway JsonPath implementation] and fully supports https://goessner.net/articles/JsonPath/[JsonPath specification].

*Example*

.Payload
------------------------
{
  "store": {
    "book": [
      {
        "category": "reference",
        "author": "Nigel Rees",
        "title": "Sayings of the Century",
        "price": 8.95
      },
      {
        "category": "fiction",
        "author": "Evelyn Waugh",
        "title": "Sword of Honour",
        "price": 12.99
      },
      {
        "category": "fiction",
        "author": "Herman Melville",
        "title": "Moby Dick",
        "isbn": "0-553-21311-3",
        "price": 8.99
      },
      {
        "category": "fiction",
        "author": "J. R. R. Tolkien",
        "title": "The Lord of the Rings",
        "isbn": "0-395-19395-8",
        "price": 22.99
      }
    ]
  }
}
------------------------
.DataSonnet map:
------------------------
{
    author: ds.jsonpath.select(payload, "$..book[-2:]..author")[0]
}
------------------------
.Result
------------------------
{
    "author": "Herman Melville"
}
------------------------

## math

### `sum(array arr)`
Returns sum of all elements in the array.

*Example*

.Payload
----------
[ 10, 20, 30 ]
----------
.DataSonnet map:
------------------------
ds.math.sum(payload)
------------------------
.Result
------------------------
60
------------------------

### `round(double num, int precision)`
Rounds a double to the number of digits after the decimal point

*Example*

.Payload
----------
{
    "num": 123.562567558
}
----------
.DataSonnet map:
------------------------
ds.math.round(payload.num, 6)
------------------------
.Result
------------------------
123.562568
------------------------

## regex

### `regexFullMatch(string pattern, string input)`
Matches the entire input against the pattern (anchored start and end). If there's no match, returns `null`. If there's a match, returns a JSON object which has the following structure:

- `string` - the matched string;
- `captures` - array of captured subgroups in the match, if any;
- `namedCaptures` - map of named subgroups, if any;

*Example*

.DataSonnet map:
------------------------
ds.regex.regexFullMatch(@'h(?P<mid>.*)o', 'hello')
------------------------
.Result
------------------------
{
  "string": "hello",
  "captures": [
    "ell"
  ],
  "namedCaptures": {
    "mid": "ell"
  }
}
------------------------

### `regexPartialMatch(string pattern, string input)`
Matches the input against the pattern (unanchored). If there's no match, returns `null`. If there's a match, returns a JSON object which has the following structure:

- `string` - the matched string;
- `captures` - array of captured subgroups in the match, if any;
- `namedCaptures` - map of named subgroups, if any;

*Example*

.DataSonnet map:
------------------------
ds.regex.regexPartialMatch(@'e(?P<mid>.*)o', 'hello')
------------------------
.Result
------------------------
{
  "string": "ello",
  "captures": [
    "ll"
  ],
  "namedCaptures": {
    "mid": "ll"
  }
}
------------------------

### `regexScan(string pattern, string input)`
Finds all matches of the input against the pattern. If there are any matches, returns an array of JSON objects which have the following structure:

- `string` - the matched string;
- `captures` - array of captured subgroups in the match, if any;
- `namedCaptures` - map of named subgroups, if any;

*Example*

.DataSonnet map:
------------------------
ds.regex.regexScan(@'(?P<user>[a-z]*)@(?P<domain>[a-z]*).org', 'modus@datasonnet.org,box@datasonnet.org')
------------------------
.Result
------------------------
[
  {
    "string": "modus@datasonnet.org",
    "captures": [
      "modus",
      "datasonnet"
    ],
    "namedCaptures": {
      "domain": "datasonnet",
      "user": "modus"
    }
  },
  {
    "string": "box@datasonnet.org",
    "captures": [
      "box",
      "datasonnet"
    ],
    "namedCaptures": {
      "domain": "datasonnet",
      "user": "box"
    }
  }
]
------------------------

### `regexQuoteMeta(string str)`
Returns a literal pattern string for the specified string.

*Example*

.DataSonnet map:
------------------------
ds.regex.regexQuoteMeta(@'1.5-2.0?')
------------------------
.Result
------------------------
"1\\.5-2\\.0\\?"
------------------------

### `regexReplace(string str, string pattern, string replacement)`
Returns the input with the first match replaced by `replacement` string.

*Example*

.DataSonnet map:
------------------------
ds.regex.regexReplace('wishyfishyisishy', @'ish', 'and')
------------------------
.Result
------------------------
"wandyfishyisishy"
------------------------

### `regexGlobalReplace(string str, string pattern, string replacement)`
Returns the input with all matches replaced by `replacement` string.

*Example*

.DataSonnet map:
------------------------
ds.regex.regexGlobalReplace('wishyfishyisishy', @'ish', 'and')
------------------------
.Result
------------------------
"wandyfandyisandy"
------------------------

## url

### `encode(string data, string encoding="UTF-8")`

Translates a string into `application/x-www-form-urlencoded` format using the supplied encoding scheme to obtain the bytes for unsafe characters. The default encoding is `UTF-8`.

*Example*

.DataSonnet map:
------------------------
ds.url.encode('Hello World')
------------------------
.Result
------------------------
"Hello+World"
------------------------

### `decode(string data, string encoding="UTF-8")`

Decodes a application/x-www-form-urlencoded string using a specific encoding scheme. The supplied encoding is used to determine what characters are represented by any consecutive sequences of the form "%xy".

*Example*

.DataSonnet map:
------------------------
ds.url.decode('Hello+World')
------------------------
.Result
------------------------
"Hello World"
------------------------
